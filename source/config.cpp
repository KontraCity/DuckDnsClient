#include "config.hpp"
using namespace kc::ConfigConst;

namespace kc {

void Config::GenerateSampleFile()
{
    std::ofstream configFile(ConfigFile, std::ios::trunc);
    if (!configFile)
        throw std::runtime_error("kc::Config::GenerateSampleFile(): Couldn't create sample configuration file");
    
    configFile << fmt::format(
        "#############################################\n"
        "###                                       ###\n"
        "### DuckDnsClient 1.1 configuration       ###\n"
        "### Generated by DuckDnsClient executable ###\n"
        "###                                       ###\n"
        "#############################################\n"
        "\n"
        
        "## Domain(s) to update\n"
        "## Duck DNS client will update this/these domain(s).\n"
        "# Should be one or more space separated strings.\n"
        "{} {}\n"
        "\n"
        
        "## Update token\n"
        "## Duck DNS client will use this token to update domain(s).\n"
        "# Should be a string.\n"
        "{} {}\n",
        
        Tags::Domains, Defaults::Domains,
        Tags::Token, Defaults::Token
    );
}

Config::Config()
{
    std::ifstream configFile(ConfigFile);
    if (!configFile)
        throw Error(fmt::format("Couldn't open configuration file \"{}\"", ConfigFile));
    
    while (!configFile.eof())
    {
        std::string line;
        std::getline(configFile, line);
        
        size_t commentStart = line.find("#");
        if (commentStart != std::string::npos)
            line.erase(line.begin() + commentStart, line.end());
        
        std::stringstream lineStream(line);
        std::string tag;
        lineStream >> tag;
        if (tag.empty())
            continue;
        
        std::vector<std::string> values;
        while (!lineStream.eof())
        {
            std::string& newValue = values.emplace_back();
            lineStream >> newValue;
        }
        if (values.empty())
            throw Error(fmt::format("\"{}\": No value found", tag));

        if (tag == Tags::Domains)
            m_domains = values;
        else if (tag == Tags::Token)
            m_token = values[0];
        else
            throw Error(fmt::format("\"{}\": Tag is unknown", tag));
    }
    
    if (m_domains.empty())
        throw Error(fmt::format("\"{}\": Tag is absent in configuration file", Tags::Domains));
    if (m_token.empty())
        throw Error(fmt::format("\"{}\": Tag is absent in configuration file", Tags::Token));
    
    std::string domains;
    for (int index = 0, size = m_domains.size(); index < size; ++index)
    {
        domains += m_domains[index];
        if (index != size - 1)
            domains += ',';
    }
    m_url = fmt::format("https://www.duckdns.org/update?domains={}&token={}&verbose=true", domains, m_token);
}

} // namespace kc
