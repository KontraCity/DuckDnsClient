#include "config.hpp"

namespace kc {

void Config::GenerateDefaultFile()
{
    using namespace ConfigConst;
    
    std::ofstream configFile(ConfigFilePath, std::ios::trunc);
    if (!configFile)
    {
        throw std::runtime_error(fmt::format(
            "kc::Config::GenerateDefaultFile(): Couldn't open configuration file \"{0}\"",
            ConfigFilePath
        ));
    }
    
    configFile << fmt::format(
        "#############################################\n"
        "###                                       ###\n"
        "### DuckDnsClient 1.1 configuration       ###\n"
        "### Generated by DuckDnsClient executable ###\n"
        "###                                       ###\n"
        "#############################################\n"
        "\n"
        
        "## Domain(s) to update\n"
        "## Duck DNS client will update this/these domain(s).\n"
        "# Should be one or more space separated strings.\n"
        "{0} my-domain\n"
        "\n"
        
        "## Update token\n"
        "## Duck DNS client will use this token to update domain(s).\n"
        "# Should be a string.\n"
        "{1} xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n",
        
        Tags::Domains,
        Tags::Token
    );
}

Config::Config()
{
    using namespace ConfigConst;
    
    std::ifstream configFile(ConfigFilePath);
    if (!configFile)
        throw Error("Couldn't open configuration file");
    
    while (!configFile.eof())
    {
        std::string line;
        std::getline(configFile, line);
        
        size_t commentStart = line.find("#");
        if (commentStart != std::string::npos)
            line.erase(line.begin() + commentStart, line.end());
        
        std::stringstream lineStream(line);
        std::string tag;
        lineStream >> tag;
        if (tag.empty())
            continue;
        
        std::vector<std::string> values;
        while (!lineStream.eof())
        {
            std::string& newValue = values.emplace_back();
            lineStream >> newValue;
        }
        if (values.empty())
            throw Error(fmt::format("\"{0}\": No value found", tag));

        if (tag == Tags::Domains)
            m_domains = values;
        else if (tag == Tags::Token)
            m_token = values[0];
        else
            throw Error(fmt::format("\"{0}\": Tag is unknown", tag));
    }
    
    if (m_domains.empty())
        throw Error(fmt::format("\"{0}\": Tag is absent in configuration file", Tags::Domains));
    if (m_token.empty())
        throw Error(fmt::format("\"{0}\": Tag is absent in configuration file", Tags::Token));
    
    std::string domains;
    for (int index = 0, size = m_domains.size(); index < size; ++index)
    {
        domains += m_domains[index];
        if (index != size - 1)
            domains += ',';
    }
    m_url = fmt::format("https://www.duckdns.org/update?domains={0}&token={1}&verbose=true", domains, m_token);
}

} // namespace kc
